# SPDX-FileCopyrightText: 2024 University of Applied Sciences Osnabrück
# SPDX-FileContributor: Andreas Schliebitz
# SPDX-FileContributor: Henri Graf
# SPDX-FileContributor: Jonas Tüpker
# SPDX-FileContributor: Lukas Hesse
# SPDX-FileContributor: Maik Fruhner
# SPDX-FileContributor: Prof. Dr.-Ing. Heiko Tapken
# SPDX-FileContributor: Tobias Wamhof
#
# SPDX-License-Identifier: AGPL-3.0-or-later

import os

from rdflib.namespace import DCTERMS
from rdflib import Namespace
from rdflib import Graph
from rdflib import Literal, URIRef

from rdflib.namespace import RDF, DCTERMS
from rdflib import Graph
from rdflib import Literal, URIRef
from rdflib import Graph, URIRef, Literal, RDF, DCTERMS, DCAT, OWL, BNode
from rdflib.namespace import XSD, PROV

from . import util

import logging
from datetime import datetime

FUSEKI_ENDPOINT = os.environ.get("FUSEKI_ENDPOINT")
SPARQL_UPDATE_ENDPOINT = f"{FUSEKI_ENDPOINT}ds/update"
SPARQL_QUERY_ENDPOINT = f"{FUSEKI_ENDPOINT}ds/sparql"

logger = logging.getLogger("api-logger")


def delete_service(service_id):
    service_id_splitted = service_id.split("#")
    service_id_splitted[-1] = "_Distribution"
    distribution_id = "#".join(service_id_splitted)

    query = f"""
        DELETE{{  ?id ?p ?o }}
            WHERE{{   
                {{
                    FILTER (?id = <{service_id}>)
                    ?id ?p ?o
                }}
                UNION
                {{
                    FILTER (?id = <{distribution_id}>)
                    ?id ?p ?o
                }}
                
            }}"""

    return util.send_update(SPARQL_UPDATE_ENDPOINT, query)


def get_metadata_information_for_service_uri(uri: str):
    query = f"""
        PREFIX hydra: <http://www.w3.org/ns/hydra/core#>

        Construct {{?sub ?pred ?obj}} WHERE {{
            ?uri (<http://w3id.org/agri-gaia-x/asset#availablePath>|<http://w3id.org/agri-gaia-x/asset#queryParameterMapping>|hydra:supportedOperation|hydra:returns)* ?sub .
            ?sub ?pred ?obj
            Filter(?uri = <{uri}>)}}
        """

    response = util.send_graph_query(util.DATASET_QUERY_ENDPOINT, query)
    return response


def delete_service_autogenerated(service_id):
    query = f"""
        PREFIX hydra: <http://www.w3.org/ns/hydra/core#> 

        DELETE {{?todelete ?pred ?obj}} WHERE {{
                <{service_id}> (<http://w3id.org/agri-gaia-x/asset#availablePath>|<http://w3id.org/agri-gaia-x/asset#queryParameterMapping>|hydra:supportedOperation|hydra:returns|hydra:supportedProperty)* ?todelete .
                ?todelete ?pred ?obj
        }}"""

    return util.send_update(SPARQL_UPDATE_ENDPOINT, query)


# Returns a default graph for a dataset, that is located inside a bucket on a server located at the passed url
#
# minio_server: the location of the minio instance
# bucket:       the bucket name
# dataset:      the dataset name


def get_default_graph(minio_server, bucket, service_name, service_id):
    graph = Graph()
    dcat = Namespace("http://www.w3.org/ns/dcat#")

    graph.bind("dcat", dcat)
    graph.bind("dct", DCTERMS)
    id_string = (
        "https://" + minio_server + "/" + bucket + "/services/" + str(service_id)
    )
    accessURL = URIRef(
        "https://"
        + minio_server
        + "/"
        + bucket
        + "/services/definitions/"
        + str(service_name)
    )
    datasetid = URIRef(id_string + "#_Service")
    distributionid = URIRef(id_string + "#_Distribution")
    graph.add((datasetid, dcat.title, Literal(service_name)))
    # TODO: link to gax:Participant which is a foaf:Agent
    # graph.add((datasetid, dcat.creator, Literal(bucket)))
    graph.add((datasetid, dcat.publisher, Literal(bucket)))
    graph.add((datasetid, dcat.distribution, distributionid))
    graph.add((distributionid, dcat.accessURL, accessURL))
    return graph, id_string


# Returns a graph for a dataset, that is located inside a bucket on a server located at the passed url.
# The dataset has to be annotated with information on used labels, the creator and the creation date.
#
# labels:       the used labels for annotation
# minio_server: the location of the minio instance
# bucket:       the bucket name
# dataset:      the dataset name
# description:  the dataset description


def create_graph(
    minio_server: str,
    bucket: str,
    service_name: str,
    service_id: int,
    description: str,
    url: str,
    labels,
):
    (graph, id_string) = get_default_graph(
        minio_server, bucket, service_name, service_id
    )
    dcat = Namespace("http://www.w3.org/ns/dcat#")
    agri_gaia = Namespace("http://w3id.org/agri-gaia-x/asset#")

    datasetid = URIRef(id_string + "#_Service")
    graph.add((datasetid, dcat.description, Literal(description)))
    graph.add((datasetid, agri_gaia.availablePath, Literal(url)))

    for label in labels:
        graph.add((datasetid, dcat.keyword, Literal(label)))

    return graph, datasetid


def create_graph_autogenerated(file_json, minio_server, service_id, bucket):
    id_string = (
        "https://"
        + minio_server
        + "/"
        + bucket
        + "/services/"
        + str(service_id)
        + "Service_Autogenerated"
    )
    # creating the main object for dataset being described
    g = Graph()
    g.bind("agri-gax", "http://w3id.org/agri-gaia-x/asset#")
    g.bind("gax-trust-framework", "http://w3id.org/gaia-x/gax-trust-framework#")
    g.bind("hydra", "http://www.w3.org/ns/hydra/core#")
    g.bind("schema", "http://schema.org/")
    g.bind("dcat", DCAT)
    g.bind("dct", DCTERMS)
    g.bind("xsd", XSD)
    g.bind("prov", PROV)
    g.bind("owl", OWL)
    # crating the main object for dataset being described
    api_service = URIRef(id_string)

    g.add(
        (
            api_service,
            RDF.type,
            URIRef("http://w3id.org/agri-gaia-x/asset#AgriApiDescription"),
        )
    )
    if "title" in file_json["info"]:
        g.add((api_service, DCTERMS.title, Literal(file_json["info"]["title"])))
    if "name" in file_json["info"]["contact"]:
        g.add(
            (
                api_service,
                URIRef("http://w3id.org/gaia-x/gax-trust-framework#name"),
                Literal(file_json["info"]["contact"]["name"]),
            )
        )
    if "description" in file_json["info"]:
        g.add(
            (
                api_service,
                DCTERMS.description,
                Literal(file_json["info"]["description"]),
            )
        )
    if "url" in file_json["info"]["contact"]:
        g.add(
            (
                api_service,
                URIRef("http://w3id.org/gaia-x/gax-trust-framework#name"),
                Literal(file_json["info"]["contact"]["name"]),
            )
        )
    # print(file_json['servers'][0]['url'])
    if "url" in file_json["servers"][0]:
        entrypoint = file_json["servers"][0]["url"]
        g.add(
            (
                api_service,
                URIRef("http://www.w3.org/ns/hydra/core#entrypoint"),
                Literal(entrypoint),
            )
        )
    if "version" in file_json["info"]:
        g.add(
            (
                api_service,
                DCAT.version,
                Literal(file_json["info"]["version"], datatype=XSD.string),
            )
        )
    for path in file_json["paths"]:
        ## when path has parameter, it wont serialize into URI directly so we have consider that condition here
        if path.find("{") == -1:
            pathURI = entrypoint + path
            # print(path)
            g.add(
                (
                    api_service,
                    URIRef("http://w3id.org/agri-gaia-x/asset#availablePath"),
                    URIRef(pathURI),
                )
            )
            g.add(
                (
                    URIRef(pathURI),
                    RDF.type,
                    URIRef("http://w3id.org/agri-gaia-x/asset#ApiPath"),
                )
            )
            g.add(
                (
                    URIRef(pathURI),
                    URIRef("http://www.w3.org/ns/hydra/core#template"),
                    Literal(path, datatype=XSD.string),
                )
            )
        else:
            param = path[path.find("{") :]
            pathURI = entrypoint + path[: path.find("{")] + "-parameterized"
            # print(pathURI)
            # print(param)
            g.add(
                (
                    api_service,
                    URIRef("http://w3id.org/agri-gaia-x/asset#availablePath"),
                    URIRef(pathURI),
                )
            )
            g.add(
                (
                    URIRef(pathURI),
                    RDF.type,
                    URIRef("http://w3id.org/agri-gaia-x/asset#ApiPath"),
                )
            )
            param_map = param[1 : param.find("}") - 1] + "-mapping"
            g.add(
                (
                    URIRef(pathURI),
                    URIRef("http://w3id.org/agri-gaia-x/asset#queryParameterMapping"),
                    URIRef(param_map),
                )
            )
            g.add(
                (
                    URIRef(param_map),
                    RDF.type,
                    URIRef("http://www.w3.org/ns/hydra/core#IriTemplate"),
                )
            )
            g.add(
                (
                    URIRef(param_map),
                    URIRef("http://www.w3.org/ns/hydra/core#template"),
                    Literal(path, datatype=XSD.string),
                )
            )

        # g.add((URIRef(pathURI), URIRef('http://w3id.org/agri-gaia-x/asset#pathUri'), Literal(path, datatype=XSD.string)))
        # g.add((URIRef(param_map), URIRef('http://www.w3.org/ns/hydra/core#template'), Literal(path, datatype=XSD.string)))
        # bnode_sup_op = BNode()
        # status_list = []
        for path_op in file_json["paths"][path]:
            bnode_sup_op = BNode()
            status_list = []
            # print(path_op)
            g.add(
                (
                    URIRef(pathURI),
                    URIRef("http://www.w3.org/ns/hydra/core#supportedOperation"),
                    bnode_sup_op,
                )
            )
            g.add(
                (
                    bnode_sup_op,
                    RDF.type,
                    URIRef("http://www.w3.org/ns/hydra/core#Operation"),
                )
            )
            g.add(
                (
                    bnode_sup_op,
                    URIRef("http://www.w3.org/ns/hydra/core#method"),
                    Literal(path_op, datatype=XSD.string),
                )
            )

            for status_resp in file_json["paths"][path][path_op]["responses"]:
                status_list.append(status_resp)
                # looking for info about returned content if exists
                # this block is only executed when info about returned object is present
                if (
                    "content"
                    in file_json["paths"][path][path_op]["responses"][status_resp]
                ):
                    bnode_resp = BNode()
                    # g.add((bnode_sup_op, URIRef('http://www.w3.org/ns/hydra/core#returns'),  Literal(file_json['paths'][path][path_op]['responses'][status_resp]['content'], datatype=XSD.string)))
                    g.add(
                        (
                            bnode_sup_op,
                            URIRef("http://www.w3.org/ns/hydra/core#returns"),
                            bnode_resp,
                        )
                    )
                    g.add(
                        (
                            bnode_resp,
                            RDF.type,
                            URIRef("http://w3id.org/agri-gaia-x/asset#responseObject"),
                        )
                    )
                    for resp_obj in file_json["paths"][path][path_op]["responses"][
                        status_resp
                    ]["content"]:
                        # g.add((bnode_resp, URIRef('http://w3id.org/agri-gaia-x/asset#responseObjectType'), Literal(resp_obj, datatype=XSD.string)))
                        g.add(
                            (
                                bnode_sup_op,
                                URIRef(
                                    "http://w3id.org/agri-gaia-x/asset#responseSerialization"
                                ),
                                Literal(resp_obj, datatype=XSD.string),
                            )
                        )

                        resp_type = file_json["paths"][path][path_op]["responses"][
                            status_resp
                        ]["content"][resp_obj]["schema"]
                        if "items" in resp_type:
                            resp_type_schema = resp_type["items"]
                            # g.add((bnode_resp, URIRef('http://www.w3.org/ns/hydra/core#supportedProperty'), Literal(resp_type['items'], datatype=XSD.string)))
                        else:
                            resp_type_schema = resp_type

                        bnode_resp_obj = BNode()
                        g.add(
                            (
                                bnode_resp,
                                URIRef(
                                    "http://www.w3.org/ns/hydra/core#supportedProperty"
                                ),
                                bnode_resp_obj,
                            )
                        )
                        g.add(
                            (
                                bnode_resp_obj,
                                RDF.type,
                                URIRef(
                                    "http://w3id.org/agri-gaia-x/asset#responseObject"
                                ),
                            )
                        )
                        # g.add((bnode_resp_obj, URIRef('http://www.w3.org/ns/hydra/core#supportedProperty'), Literal(resp_type, datatype=XSD.string)))
                        ## check if it has reference to schema for more information on returned object
                        if "$ref" in resp_type_schema:
                            print(resp_type_schema["$ref"])
                            resp_ref = resp_type_schema["$ref"][
                                resp_type_schema["$ref"].rfind("/") + 1 :
                            ]
                            resp_schema = file_json["components"]["schemas"][resp_ref][
                                "properties"
                            ]
                            for prop in resp_schema:
                                print(prop)
                                bnode_sup_prop = BNode()
                                # g.add((bnode_resp_obj, URIRef('http://www.w3.org/ns/hydra/core#supportedProperty'), Literal(prop, datatype=XSD.string)))
                                g.add(
                                    (
                                        bnode_resp_obj,
                                        URIRef(
                                            "http://www.w3.org/ns/hydra/core#supportedProperty"
                                        ),
                                        bnode_sup_prop,
                                    )
                                )
                                g.add(
                                    (
                                        bnode_sup_prop,
                                        RDF.type,
                                        URIRef(
                                            "http://www.w3.org/ns/hydra/core#SupportedProperty"
                                        ),
                                    )
                                )
                                g.add(
                                    (
                                        bnode_sup_prop,
                                        URIRef("http://www.w3.org/ns/hydra/core#title"),
                                        Literal(prop, datatype=XSD.string),
                                    )
                                )
                                if "type" in resp_schema[prop]:
                                    # print(resp_schema[prop]['type'])
                                    g.add(
                                        (
                                            bnode_sup_prop,
                                            DCTERMS.type,
                                            Literal(
                                                resp_schema[prop]["type"],
                                                datatype=XSD.string,
                                            ),
                                        )
                                    )
                        elif "format" in resp_type_schema:
                            print(resp_type_schema["format"])
                            g.add(
                                (
                                    bnode_resp_obj,
                                    URIRef(
                                        "http://www.w3.org/ns/hydra/core#supportedProperty"
                                    ),
                                    Literal(resp_type_schema, datatype=XSD.string),
                                )
                            )

            # print(status_list)
            for status in status_list:
                g.add(
                    (
                        bnode_sup_op,
                        URIRef("http://www.w3.org/ns/hydra/core#possibleStatus"),
                        Literal(status, datatype=XSD.int),
                    )
                )

        # print(path)
        # for response in file_json['paths'][path]:
        #    print(response)

    g.add(
        (
            api_service,
            DCTERMS.issued,
            Literal(
                datetime.today().strftime("%Y-%m-%d %H:%M:%S"), datatype=XSD.dateTime
            ),
        )
    )
    g.add(
        (
            api_service,
            DCTERMS.modified,
            Literal(
                datetime.today().strftime("%Y-%m-%d %H:%M:%S"), datatype=XSD.dateTime
            ),
        )
    )

    return g, api_service
